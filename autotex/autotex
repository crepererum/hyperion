#!/usr/bin/env python3

import argparse
import binascii
import fcntl
import gzip
import hashlib
import msgpack
import operator
import os
import os.path
import re
import shutil
import signal
import subprocess
import sys
import tempfile
import time
import yaml


###############################################################################
################### HELPER LIBS ###############################################
###############################################################################
def get_equivalent(container, item, default=None):
    for x in container:
        if x == item:
            return x
    return default


###############################################################################
################### CLASSES ###################################################
###############################################################################
class Action:
    def __init__(self, dirty=True):
        self.deps = set()
        self.influences = set()
        self.dirty = dirty

    def __str__(self):
        return 'unknown action'

    def to_json(self):
        deps = []
        for x in self.deps:
            deps.append(x._id)

        influences = []
        for x in self.influences:
            influences.append(x._id)

        dirty = self.dirty

        state = self.__dict__.copy()
        del state['_id']
        del state['deps']
        del state['influences']
        del state['dirty']

        return {
            'id': self._id,
            'type': type(self).__name__,
            'deps': deps,
            'influences': influences,
            'dirty': dirty,
            'state': state
        }

    def from_json(self, j):
        self.__dict__ = j['state']
        self.deps = set()
        self.influences = set()
        self.dirty = j['dirty']

    def add_dependency(self, other):
        self.deps.add(other)
        other.influences.add(self)

    def merge(self, other):
        self.deps.update(other.deps)
        for d in other.deps:
            d.influences.remove(other)
            d.influences.add(self)

        self.influences.update(other.influences)
        for i in other.influences:
            i.deps.remove(other)
            i.deps.add(self)

    def priority(self):
        return 0

    def needs_update(self):
        return self.dirty

    def check_status(self):
        return 0

    def update(self):
        self.dirty = False
        for action in self.influences:
            action.dirty = True

        return []


class FileAction(Action):
    def __init__(self, path, checksum=None):
        super().__init__()
        self.path = path
        self.checksum = checksum

    def __eq__(self, other):
        if isinstance(other, FileAction):
            return self.path == other.path
        else:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.path)

    def __str__(self):
        return 'watch "' + self.path + '"'

    def priority(self):
        return -100

    def needs_update(self):
        return super().needs_update() \
            or (self.checksum != self.calc_file_checksum())

    def update(self):
        self.checksum = self.calc_file_checksum()
        checksum_string = str(binascii.hexlify(self.checksum), 'utf8')
        print('File changed: "' + self.path
              + '" (Checksum=' + checksum_string + ')')
        super().update()
        return []

    def calc_file_checksum(self):
        try:
            f = open(self.path, 'rb')
            checksum = hashlib.sha256(f.read()).digest()
            f.close()
            return checksum
        except IOError:
            return b''


class CommandAction(Action):
    def __init__(self, command, ignores=[]):
        super().__init__()
        self.command = command
        self.ignores = ignores
        self.status = None

    def __eq__(self, other):
        if isinstance(other, CommandAction):
            return (self.command == other.command) \
                and (self.ignores == other.ignores)
        else:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.command)

    def __str__(self):
        return self.command

    def priority(self):
        return 100

    def check_status(self):
        return self.status

    def update(self):
        # run child process and redirect output
        sys.stdout.write(self.command + ': -')
        sys.stdout.flush()
        tfname = config['tmpdir'] + '/trace.log'
        cmd = TRACE_CMD + ' ' + tfname + ' ' + self.command
        child = None
        self.status = None
        try:
            child = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            fcntl.fcntl(child.stdout, fcntl.F_SETFL, os.O_NONBLOCK)
            fcntl.fcntl(child.stderr, fcntl.F_SETFL, os.O_NONBLOCK)
            flog = open(config['log'], 'a')
            self.print_log_header(flog)
            counter = 0
            while self.status is None:
                s = child.poll()
                out = child.stdout.read(1)
                err = child.stderr.read(1)
                if (s is not None) and (out == '') and (err == ''):
                    self.status = s

                changed = False
                if out != '':
                    flog.write(out)
                    flog.flush()
                    if config['print_stdout']:
                        self.print_char(out, counter)
                    changed = True
                if err != '':
                    flog.write(err)
                    flog.flush()
                    if config['print_stderr']:
                        self.print_char(err, counter)
                    changed = True

                if changed:
                    counter = (counter + 1) % 4
                    sys.stdout.write('\b')
                    self.print_process(counter)
                else:
                    time.sleep(0.05)
        except KeyboardInterrupt:
            if child:
                child.terminate()
            raise

        # get and analyze trace log
        f = open(tfname)
        targets = analyze_trace(f)
        f.close()

        # generate new actions and deps
        fas = set(
            FileAction(path) for path in targets
            if not self.file_ignored(path)
        ).difference(self.deps)
        for fa in fas:
            self.add_dependency(fa)
        result = [a for fa in fas for a in detect_actions(fa.path)] + list(fas)

        flog.close()
        if self.status == 0:
            print('\bOK')
        else:
            print('\bFAILED(' + str(self.status) + ')')
        super().update()
        return result

    def file_ignored(self, path):
        for ext in self.ignores:
            if re.search(ext, path):
                return True

        return False

    def print_process(self, counter):
        sys.stdout.write('-/|\\'[counter])
        sys.stdout.flush()

    def print_char(self, c, counter):
        sys.stdout.write('\b')
        if c == '\n':
            sys.stdout.write(' ')
        sys.stdout.write(c)
        self.print_process(counter)

    def print_log_header(self, flog):
        flog.write('\n')
        flog.write(2 * ((80 * '+') + '\n'))
        flog.write(('+' * 10) + str(self) + '\n')
        flog.write(2 * ((80 * '+') + '\n'))


class TexBibAction(CommandAction):
    def __init__(self, path):
        self.path = path
        super().__init__(
            command='biber ' + self.path,
            ignores=[r"\.blg$"]
        )


class TexCompileAction(CommandAction):
    def __init__(self, path, engine='luatex', latex=True, format='pdf'):
        self.path = path
        self.engine = engine.lower()
        self.latex = latex
        self.format = format.lower()

        cmd = ''
        if self.engine == 'luatex':
            if self.latex:
                cmd = 'lualatex'
            else:
                cmd = 'luatex'

            cmd = cmd + ' --file-line-error --interaction=nonstopmode'

            if self.format in ['dvi', 'pdf']:
                cmd = cmd + ' --output-format=' + self.format
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by LuaTeX!')
        elif self.engine == 'xetex':
            if self.latex:
                cmd = 'xelatex'
            else:
                cmd = 'xetex'

            cmd = cmd + ' -file-line-error -interaction=batchmode'

            if self.format == 'pdf':
                pass
            elif self.format == 'xdv':
                cmd = cmd + ' -no-pdf'
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by XeTeX!')
        elif self.engine == 'pdftex':
            if self.format == 'pdf':
                cmd = 'pdf'
            elif self.format == 'dvi':
                cmd = ''
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by pdfTeX!')

            if self.latex:
                cmd = cmd + 'latex'
            else:
                cmd = cmd + 'tex'

            cmd = cmd + ' -file-line-error -interaction=batchmode'
        else:
            raise Exception('Unsupported engine(' + self.engine + ')!')

        cmd = cmd + ' ' + self.path

        super().__init__(
            command=cmd,
            ignores=[r"\.log$", r"\.pdf$"]
        )


class TexIndexAction(CommandAction):
    def __init__(self, path, out, style):
        self.path = path
        self.out = out
        self.style = style
        super().__init__('makeindex -q -s ' + self.style
                         + ' -o ' + self.out
                         + ' ' + self.path)


###############################################################################
################### CONSTANTS #################################################
###############################################################################
RE_TRACELINE = re.compile(r"""
    ^
    \d+                    # PID (dropped)
    \s+
    (?P<func> \w+ )        # function
    \(
    (?P<args> [^)]* )      # arguments
    \) \s* = \s*
    [0-9-]+                # status code (dropped)
                           # additional infos (dropped)
    """, re.VERBOSE)

STATE_VERSION = 1

TARGET_MAP = {
    'access':    0,
    'execve':    0,
    'getcwd':    0,
    'lstat':     0,
    'mkdir':     0,
    'open':      0,
    'openat':    1,
    'readlink':  0,
    'stat':      0,
    'unlink':    0
}

TRACE_CMD = 'strace -e trace=file -f -qq -y -o'

YAML_PATCH = '?+'
YAML_REMOVE = '?-'


###############################################################################
################### GLOBALS ###################################################
###############################################################################
_tmpdir = tempfile.TemporaryDirectory()

config = {
    'append_log': False,
    'basedir': os.path.abspath(os.getcwd()),
    'command_map': {
        r"\.bcf": {
            'type': 'TexBibAction',
            'args': {
                'path': '?p'
            },
            'auto': True
        },
        r"\.(ins)|(dtx)|(tex)$": {
            'type': 'TexCompileAction',
            'args': {
                'path': '?p'
            },
            'auto': False
        },
        r"\.idx$": {
            'type': 'TexIndexAction',
            'args': {
                'path': '?p',
                'style': 'gind.ist',
                'out': '?w.ind'
            },
            'auto': True
        }
    },
    'continuously': False,
    'continuously_wait': 3,
    'log': 'autotex.log',
    'max_rounds': 10,
    'print_stdout': False,
    'print_stderr': True,
    'state': '.autotex.state',
    'tmpdir': _tmpdir.name,
    'verbose': False
}


###############################################################################
################### ORPHAN METHODS ############################################
###############################################################################
def detect_actions(path, auto_only=True):
    # find commands
    commands = config['command_map'].items()
    ok_auto = (
        not auto_only or (('auto' in cmd) and (cmd['auto'] is True))
        for ext, cmd in commands
    )
    ok_path = (
        bool(re.search(ext, path))
        for ext, cmd in commands
    )
    ok = (
        all(t)
        for t in zip(ok_auto, ok_path)
    )
    commands_filtered = (
        t
        for t, o in zip(commands, ok)
        if o
    )

    # find all matching commands
    actions = []
    for ext, cmd in commands_filtered:
        # get action and args
        t = globals()[cmd['type']]
        args = {}
        if 'args' in cmd:
            args = cmd['args'].copy()

        # substitute string arguments
        s_path = path
        s_woext, s_ext = os.path.splitext(path)
        s_dir, s_basename = os.path.split(path)
        d = {
            '??': '?',
            '?b': s_basename,
            '?d': s_dir,
            '?e': s_ext,
            '?p': s_path,
            '?w': s_woext
        }
        pattern = re.compile('|'.join(re.escape(k) for k in d.keys()))
        for key, value in args.items():
            if type(value) == str:
                args[key] = pattern.sub(lambda x: d[x.group()], value)

        # construct Action object
        actions.append(t(**args))

    return actions


def analyze_trace(f):
    matches = (
        RE_TRACELINE.search(l)
        for l in f
    )
    parsed = (
        (m.group('func'), m.group('args').split(', '))
        for m in matches
        if m
    )
    targets = (
        os.path.abspath(args[TARGET_MAP[func]].replace('"', ''))
        for func, args in parsed
        if func in TARGET_MAP
    )
    return set(
        os.path.relpath(t)
        for t in targets
        if os.path.commonprefix([config['basedir'], t]) == config['basedir']
    )


def patch_list(orig, patch):
    l = []
    if orig:
        l = orig.copy()

    for entry in patch:
        if entry is not None:
            if (type(entry) == str) and entry.startswith(YAML_REMOVE):
                l = [x for x in l if x != entry[len(YAML_REMOVE):]]
            elif (type(entry) == str) and entry.startswith(YAML_PATCH):
                # ignore
                pass
            else:
                l.append(entry)

    return l


def patch_dict(orig, patch):
    d = {}
    if orig:
        d = orig.copy()

    for key, value in patch.items():
        if value is not None:
            if key.startswith(YAML_REMOVE):
                tmp_key = key[len(YAML_REMOVE):]
                d.pop(tmp_key, None)
            elif value == YAML_REMOVE:
                d.pop(key, None)
            elif key == YAML_PATCH:
                # ignore
                pass
            elif key.startswith(YAML_PATCH) and (type(value) == dict):
                tmp_key = key[len(YAML_PATCH):]
                orig = None
                if (tmp_key in d) and (type(d[tmp_key]) == dict):
                    orig = d[tmp_key]
                d[tmp_key] = patch_dict(orig, value)
            elif key.startswith(YAML_PATCH) and (type(value) == list):
                tmp_key = key[len(YAML_PATCH):]
                orig = None
                if (tmp_key in d) and (type(d[tmp_key]) == list):
                    orig = d[tmp_key]
                d[tmp_key] = patch_list(orig, value)
            else:
                d[key] = value

    return d


def restore_state():
    actions = None
    sf = None

    try:
        # load data from file
        sf = gzip.open(config['state'], 'rb')
        state = msgpack.unpackb(sf.read(), encoding='utf-8')

        # version check
        if not 'state_version' in state \
                or state['state_version'] != STATE_VERSION:
            raise Exception('Incompatible state version!')

        # create objects
        actions = state['actions']
        table = {}
        for j in actions:
            t = globals()[j['type']]
            obj = t.__new__(t)
            obj.from_json(j)
            table[j['id']] = obj

        # restore dependency graph
        result = set()
        for j in actions:
            o = table[j['id']]

            o.deps.update(table[y] for y in j['deps'])
            o.influences.update(table[y] for y in j['influences'])

            result.add(o)

        actions = result
        print('State restored from file')
    except Exception:
        pass
    finally:
        if sf:
            sf.close()

    return actions


def initialize_state(files):
    return set(a for f in files for a in detect_actions(f, False))


def save_state(actions):
    # assign IDs
    for i, a in enumerate(actions):
        a._id = i

    # build state
    state = {
        'state_version': STATE_VERSION,
        'actions': [a.to_json() for a in actions]
    }

    # write to temporary file
    state_tmp = config['state'] + '.new'
    sf = gzip.GzipFile(
        filename=config['state'],
        fileobj=open(state_tmp, 'wb')
    )
    sf.write(msgpack.packb(state, use_bin_type=True))
    sf.flush()
    os.fsync(sf)
    sf.close()

    # finally overwrite old file
    shutil.move(state_tmp, config['state'])


def main():
    global config

    # parse command line arguments
    parser = argparse.ArgumentParser(
        description='Compiles .tex files to PDFs using LuaLaTeX'
    )
    parser.add_argument(
        'files',
        nargs='*',
        help='initial processed filed'
    )
    parser.add_argument(
        '--log', '-l',
        type=str,
        help='Log file'
    )
    parser.add_argument(
        '--append_log',
        action='store_true',
        help='Append new entries to log file'
    )
    parser.add_argument(
        '--config', '-c',
        type=str,
        default='.autotexrc',
        help='Config file (YAML)'
    )
    parser.add_argument(
        '--continuously', '-e',
        action='store_true',
        default=None,
        help='Update build continuously'
    )
    parser.add_argument(
        '--state', '-s',
        type=str,
        help='File that stores the serialized state of autotex'
    )
    parser.add_argument(
        '-verbose', '-v',
        action='store_true',
        default=None,
        help='verbose output'
    )
    args = parser.parse_args()
    if not args.files:
        args.files = None

    # generate config
    cf = None
    try:
        cf = open(args.config)
        config = patch_dict(config, yaml.load(cf.read()))
    except Exception:
        pass
    finally:
        if cf:
            cf.close()
    config = patch_dict(config, vars(args))

    # clear log?
    if not config['append_log']:
        open(config['log'], 'w').close()

    # try to restore or initialize state
    actions = restore_state()
    if not actions:
        if config['files']:
            actions = initialize_state(config['files'])
        else:
            parser.print_usage()
            exit(1)

    if not actions:
        print('Error: no matching action for this file!')
        exit(1)

    # main loop (fixpoint iteration)
    changed = True
    rounds = 0
    terminate = False
    while changed and not terminate:
        changed = False
        schedule = sorted((a for a in actions if a.needs_update()),
                          key=operator.methodcaller('priority'))

        try:
            # update actions
            for a in schedule:
                novel = a.update()

                # merge new actions to existing ones
                for n in novel:
                    if n in actions:
                        get_equivalent(actions, n).merge(n)
                    else:
                        actions.add(n)

                changed = True
        except KeyboardInterrupt:
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print()
            print('Interrupted')
            terminate = True

        # debug prints
        if config['verbose']:
            print()
            print('Tracked commands:')
            for a in actions:
                print(str(a))
            print()

        # safe state
        if changed:
            save_state(actions)
        elif config['continuously'] and not terminate:
            sys.stdout.write('Nothing to do, wait')
            sys.stdout.flush()
            try:
                while not any(a.needs_update() for a in actions):
                    sys.stdout.write('.')
                    sys.stdout.flush()
                    time.sleep(config['continuously_wait'])
                print('got something!')
                changed = True
                rounds = 0
            except KeyboardInterrupt:
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                print()
                print('Interrupted')
                terminate = True
            continue

        rounds = rounds + 1
        if (config['max_rounds'] != 0) \
                and (rounds > config['max_rounds']) \
                and not terminate:
            print('Error: Reached maximum number of rounds!')
            exit(1)

    # check status of all actions
    if any(a.check_status() for a in actions):
        print('There are some errors')
        exit(1)

    print('done')

if __name__ == '__main__':
    main()
