#!/usr/bin/env python3

import argparse
import binascii
import fcntl
import hashlib
import json
import operator
import os
import os.path
import re
import shutil
import signal
import subprocess
import sys
import tempfile
import time
import yaml


###############################################################################
################### HELPER LIBS ###############################################
###############################################################################
def get_equivalent(container, item, default=None):
    for x in container:
        if x == item:
            return x
    return default


###############################################################################
################### CLASSES ###################################################
###############################################################################
class Action:
    def __init__(self):
        self.deps = set()
        self.influences = set()
        self.dirty = False

    def __str__(self):
        return 'unknown action'

    def to_json(self):
        deps = []
        for x in self.deps:
            deps.append(x._id)

        influences = []
        for x in self.influences:
            influences.append(x._id)

        state = self.__dict__.copy()
        del state['_id']
        del state['deps']
        del state['influences']

        return {
            'id': self._id,
            'type': type(self).__name__,
            'deps': deps,
            'influences': influences,
            'state': state
        }

    def from_json(self, j):
        self.__dict__ = j['state']
        self.deps = set()
        self.influences = set()

    def add_dependency(self, other):
        self.deps.add(other)
        other.influences.add(self)

    def merge(self, other):
        self.deps.update(other.deps)
        for d in other.deps:
            d.influences.remove(other)
            d.influences.add(self)

        self.influences.update(other.influences)
        for i in other.influences:
            i.deps.remove(other)
            i.deps.add(self)

    def priority(self):
        return 0

    def needs_update(self):
        return self.dirty

    def check_status(self):
        return 0

    def update(self):
        self.dirty = False
        for action in self.influences:
            action.dirty = True

        return []


class FileAction(Action):
    def __init__(self, path, checksum=None):
        super().__init__()
        self.path = path
        self.checksum = checksum

    def __eq__(self, other):
        if isinstance(other, FileAction):
            return self.path == other.path
        else:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.path)

    def __str__(self):
        return 'watch "' + self.path + '"'

    def priority(self):
        return -100

    def needs_update(self):
        return super().needs_update() \
            or (self.checksum != self.calc_file_checksum())

    def update(self):
        self.checksum = self.calc_file_checksum()
        print('File changed: "' + self.path
              + '" (Checksum=' + self.checksum + ')')
        super().update()
        return []

    def calc_file_checksum(self):
        try:
            f = open(self.path, 'rb')
            checksum = hashlib.sha256(f.read()).digest()
            f.close()
            return str(binascii.hexlify(checksum), 'utf8')
        except IOError:
            return '0'


class CommandAction(Action):
    def __init__(self, command, ignores=[]):
        super().__init__()
        self.command = command
        self.ignores = ignores
        self.status = None

    def __eq__(self, other):
        if isinstance(other, CommandAction):
            return (self.command == other.command) \
                and (self.ignores == other.ignores)
        else:
            return False

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(self.command)

    def __str__(self):
        return self.command

    def priority(self):
        return 100

    def check_status(self):
        return self.status

    def update(self):
        # run child process and redirect output
        print(self.command + ': -', end='')
        tfname = config['tmpdir'] + '/trace.log'
        cmd = TRACE_CMD + ' ' + tfname + ' ' + self.command
        sys.stdout.flush()
        child = None
        self.status = None
        try:
            child = subprocess.Popen(
                cmd,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            fcntl.fcntl(child.stdout, fcntl.F_SETFL, os.O_NONBLOCK)
            fcntl.fcntl(child.stderr, fcntl.F_SETFL, os.O_NONBLOCK)
            flog = open(config['log'], 'a')
            self.print_log_header(flog)
            counter = 0
            while self.status is None:
                s = child.poll()
                out = child.stdout.read(1)
                err = child.stderr.read(1)
                if (s is not None) and (out == '') and (err == ''):
                    self.status = s

                changed = False
                if out != '':
                    flog.write(out)
                    flog.flush()
                    if config['print_stdout']:
                        self.print_char(out, counter)
                    changed = True
                if err != '':
                    flog.write(err)
                    flog.flush()
                    if config['print_stderr']:
                        self.print_char(err, counter)
                    changed = True

                if changed:
                    counter = (counter + 1) % 4
                    sys.stdout.write('\b')
                    self.print_process(counter)
                else:
                    time.sleep(0.05)
        except KeyboardInterrupt:
            if child:
                child.terminate()
            raise

        # get and analyze trace log
        f = open(tfname)
        targets = analyze_trace(f)
        f.close()

        # generate new actions and deps
        result = []
        for path in targets:
            if not self.file_ignored(path):
                fa = FileAction(path)

                if not fa in self.deps:
                    self.add_dependency(fa)
                    result.append(fa)

                    # some files results in new commands
                    actions = detect_actions(path)
                    if actions:
                        for a in actions:
                            a.add_dependency(fa)
                        result.extend(actions)

        flog.close()
        if self.status == 0:
            print('\bOK')
        else:
            print('\bFAILED(' + str(self.status) + ')')
        super().update()
        return result

    def file_ignored(self, path):
        for ext in self.ignores:
            if re.search(ext, path):
                return True

        return False

    def print_process(self, counter):
        if counter == 0:
            sys.stdout.write('-')
        elif counter == 1:
            sys.stdout.write('/')
        elif counter == 2:
            sys.stdout.write('|')
        elif counter == 3:
            sys.stdout.write('\\')
        sys.stdout.flush()

    def print_char(self, c, counter):
        sys.stdout.write('\b')
        if c == '\n':
            sys.stdout.write(' ')
        sys.stdout.write(c)
        self.print_process(counter)

    def print_log_header(self, flog):
        flog.write('\n')
        flog.write(('+' * 80) + '\n')
        flog.write(('+' * 80) + '\n')
        flog.write(('+' * 10) + str(self) + '\n')
        flog.write(('+' * 80) + '\n')
        flog.write(('+' * 80) + '\n')


class TexBibAction(CommandAction):
    def __init__(self, path):
        self.path = path
        super().__init__(
            command='biber ' + self.path,
            ignores=[r"\.blg$"]
        )


class TexCompileAction(CommandAction):
    def __init__(self, path, engine='luatex', latex=True, format='pdf'):
        self.path = path
        self.engine = engine.lower()
        self.latex = latex
        self.format = format.lower()

        cmd = ''
        if self.engine == 'luatex':
            if self.latex:
                cmd = 'lualatex'
            else:
                cmd = 'luatex'

            cmd = cmd + ' --file-line-error --interaction=nonstopmode'

            if self.format in ['dvi', 'pdf']:
                cmd = cmd + ' --output-format=' + self.format
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by LuaTeX!')
        elif self.engine == 'xetex':
            if self.latex:
                cmd = 'xelatex'
            else:
                cmd = 'xetex'

            cmd = cmd + ' -file-line-error -interaction=batchmode'

            if self.format == 'pdf':
                pass
            elif self.format == 'xdv':
                cmd = cmd + ' -no-pdf'
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by XeTeX!')
        elif self.engine == 'pdftex':
            if self.format == 'pdf':
                cmd = 'pdf'
            elif self.format == 'dvi':
                cmd = ''
            else:
                raise Exception('Format(' + self.format
                                + ') is not supported by pdfTeX!')

            if self.latex:
                cmd = cmd + 'latex'
            else:
                cmd = cmd + 'tex'

            cmd = cmd + ' -file-line-error -interaction=batchmode'
        else:
            raise Exception('Unsupported engine(' + self.engine + ')!')

        cmd = cmd + ' ' + self.path

        super().__init__(
            command=cmd,
            ignores=[r"\.log$", r"\.pdf$"]
        )


class TexIndexAction(CommandAction):
    def __init__(self, path, out, style):
        self.path = path
        self.out = out
        self.style = style
        super().__init__('makeindex -q -s ' + self.style
                         + ' -o ' + self.out
                         + ' ' + self.path)


class MyEncoder(json.JSONEncoder):
    def default(self, o):
        # assign IDs
        i = 0
        for x in o:
            x._id = i
            i = i + 1

        # dump all objects
        l = []
        for x in o:
            l.append(x.to_json())

        return l

###############################################################################
################### CONSTANTS #################################################
###############################################################################
RE_TRACELINE = re.compile(r"""
    ^
    \d+                    # PID (dropped)
    \s+
    (?P<func> \w+ )        # function
    \(
    (?P<args> [^)]* )      # arguments
    \) \s* = \s*
    [0-9-]+                # status code (dropped)
                           # additional infos (dropped)
    """, re.VERBOSE)

TARGET_MAP = {
    'access':    0,
    'execve':    0,
    'getcwd':    0,
    'lstat':     0,
    'mkdir':     0,
    'open':      0,
    'openat':    1,
    'readlink':  0,
    'stat':      0,
    'unlink':    0
}

TRACE_CMD = 'strace -e trace=file -f -qq -y -o'

YAML_PATCH = '?+'
YAML_REMOVE = '?-'


###############################################################################
################### GLOBALS ###################################################
###############################################################################
_tmpdir = tempfile.TemporaryDirectory()

config = {
    'append_log': False,
    'basedir': os.path.abspath(os.getcwd()),
    'command_map': {
        r"\.bcf": {
            'type': 'TexBibAction',
            'args': {
                'path': '?p'
            },
            'auto': True
        },
        r"\.(ins)|(dtx)|(tex)$": {
            'type': 'TexCompileAction',
            'args': {
                'path': '?p'
            },
            'auto': False
        },
        r"\.idx$": {
            'type': 'TexIndexAction',
            'args': {
                'path': '?p',
                'style': 'gind.ist',
                'out': '?w.ind'
            },
            'auto': True
        }
    },
    'continuously': False,
    'continuously_wait': 3,
    'log': 'autotex.log',
    'max_rounds': 10,
    'print_stdout': False,
    'print_stderr': True,
    'state': '.autotex.state',
    'tmpdir': _tmpdir.name,
    'verbose': False
}


###############################################################################
################### ORPHAN METHODS ############################################
###############################################################################
def detect_actions(path, auto_only=True):
    actions = []

    # find all matching commands
    for ext, cmd in config['command_map'].items():
        # auto filter
        ok_auto = None
        if auto_only:
            if ('auto' in cmd) and (cmd['auto'] is True):
                ok_auto = True
            else:
                ok_auto = False
        else:
            ok_auto = True

        # path filter
        ok_path = None
        if re.search(ext, path):
            ok_path = True
        else:
            ok_path = False

        # shoot if ok
        if ok_auto and ok_path:
            # get action and args
            t = globals()[cmd['type']]
            args = {}
            if 'args' in cmd:
                args = cmd['args'].copy()

            # substitute string arguments
            s_path = path
            s_woext, s_ext = os.path.splitext(path)
            s_dir, s_basename = os.path.split(path)
            for key, value in args.items():
                if type(value) == str:
                    value = value.replace('??', '\0')
                    value = value.replace('?p', s_path)
                    value = value.replace('?w', s_woext)
                    value = value.replace('?e', s_ext)
                    value = value.replace('?d', s_dir)
                    value = value.replace('?b', s_basename)
                    value = value.replace('\0', '?')
                    args[key] = value

            # construct Action object
            actions.append(t(**args))

    return actions


def analyze_trace(f):
    targets = set()

    # analyze all lines
    for l in f:
        m = RE_TRACELINE.search(l)

        # valid line?
        if (m):
            func = m.group('func')
            args_raw = m.group('args')
            args = args_raw.split(', ')

            # can we get the target?
            if func in TARGET_MAP:
                target_rel = args[TARGET_MAP[func]].replace('"', '')
                target = os.path.abspath(target_rel)

                # is this a local file?
                if os.path.commonprefix([config['basedir'], target]) \
                        == config['basedir']:
                    targets.add(os.path.relpath(target))

    return targets


def decode_json(f):
    a = json.load(f)
    table = {}
    for j in a:
        t = globals()[j['type']]
        obj = t.__new__(t)
        obj.from_json(j)
        table[j['id']] = obj

    result = set()
    for j in a:
        o = table[j['id']]

        for y in j['deps']:
            o.deps.add(table[y])

        for y in j['influences']:
            o.influences.add(table[y])

        result.add(o)

    return result


def patch_list(orig, patch):
    l = []
    if orig:
        l = orig.copy()

    for entry in patch:
        if entry is not None:
            if (type(entry) == str) and entry.startswith(YAML_REMOVE):
                l = [x for x in l if x != entry[len(YAML_REMOVE):]]
            elif (type(entry) == str) and entry.startswith(YAML_PATCH):
                # ignore
                pass
            else:
                l.append(entry)

    return l


def patch_dict(orig, patch):
    d = {}
    if orig:
        d = orig.copy()

    for key, value in patch.items():
        if value is not None:
            if key.startswith(YAML_REMOVE):
                tmp_key = key[len(YAML_REMOVE):]
                d.pop(tmp_key, None)
            elif value == YAML_REMOVE:
                d.pop(key, None)
            elif key == YAML_PATCH:
                # ignore
                pass
            elif key.startswith(YAML_PATCH) and (type(value) == dict):
                tmp_key = key[len(YAML_PATCH):]
                orig = None
                if (tmp_key in d) and (type(d[tmp_key]) == dict):
                    orig = d[tmp_key]
                d[tmp_key] = patch_dict(orig, value)
            elif key.startswith(YAML_PATCH) and (type(value) == list):
                tmp_key = key[len(YAML_PATCH):]
                orig = None
                if (tmp_key in d) and (type(d[tmp_key]) == list):
                    orig = d[tmp_key]
                d[tmp_key] = patch_list(orig, value)
            else:
                d[key] = value

    return d


def restore_state():
    actions = None
    sf = None
    try:
        sf = open(config['state'], 'r')
        actions = decode_json(sf)
        print('State restored from file')
    except Exception:
        pass
    finally:
        if sf:
            sf.close()

    return actions


def initialize_state(files):
    actions = set()

    for f in files:
        fa = FileAction(f)
        ta = detect_actions(f, False)
        if ta:
            for a in ta:
                a.add_dependency(fa)
            actions.add(fa)
            actions.update(ta)

    return actions


def save_state(actions):
    state_tmp = config['state'] + '.new'
    sf = open(state_tmp, 'w')
    json.dump(actions, sf, cls=MyEncoder)
    sf.close()
    shutil.move(state_tmp, config['state'])


def main():
    global config

    # parse command line arguments
    parser = argparse.ArgumentParser(
        description='Compiles .tex files to PDFs using LuaLaTeX'
    )
    parser.add_argument(
        'files',
        nargs='*',
        help='initial processed filed'
    )
    parser.add_argument(
        '--log', '-l',
        type=str,
        help='Log file'
    )
    parser.add_argument(
        '--append_log',
        action='store_true',
        help='Append new entries to log file'
    )
    parser.add_argument(
        '--config', '-c',
        type=str,
        default='.autotexrc',
        help='Config file (YAML)'
    )
    parser.add_argument(
        '--continuously', '-e',
        action='store_true',
        default=None,
        help='Update build continuously'
    )
    parser.add_argument(
        '--state', '-s',
        type=str,
        help='File that stores the serialized state of autotex'
    )
    parser.add_argument(
        '-verbose', '-v',
        action='store_true',
        default=None,
        help='verbose output'
    )
    args = parser.parse_args()
    if not args.files:
        args.files = None

    # generate config
    cf = None
    try:
        cf = open(args.config)
        config = patch_dict(config, yaml.load(cf.read()))
    except Exception:
        pass
    finally:
        if cf:
            cf.close()
    config = patch_dict(config, vars(args))

    # clear log?
    if not config['append_log']:
        flog = open(config['log'], 'w')
        flog.close()

    # try to restore or initialize state
    actions = restore_state()
    if not actions:
        if config['files']:
            actions = initialize_state(config['files'])
        else:
            parser.print_usage()
            exit(1)

    if not actions:
        print('Error: no matching action for this file!')
        exit(1)

    # main loop (fixpoint iteration)
    changed = True
    rounds = 0
    terminate = False
    while changed and not terminate:
        changed = False
        schedule = sorted([a for a in actions if a.needs_update()],
                          key=operator.methodcaller('priority'))

        try:
            # update actions
            for a in schedule:
                novel = a.update()

                # merge new actions to existing ones
                for n in novel:
                    if n in actions:
                        get_equivalent(actions, n).merge(n)
                    else:
                        actions.add(n)

                changed = True
        except KeyboardInterrupt:
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print()
            print('Interrupted')
            terminate = True

        # debug prints
        if config['verbose']:
            print()
            print('Tracked commands:')
            for a in actions:
                print(str(a))
            print()

        # safe state
        if changed:
            save_state(actions)
        elif config['continuously'] and not terminate:
            sys.stdout.write('Nothing to do, wait')
            sys.stdout.flush()
            try:
                while not any(a.needs_update() for a in actions):
                    sys.stdout.write('.')
                    sys.stdout.flush()
                    time.sleep(config['continuously_wait'])
                print('got something!')
                changed = True
                rounds = 0
            except KeyboardInterrupt:
                signal.signal(signal.SIGINT, signal.SIG_IGN)
                print()
                print('Interrupted')
                terminate = True
            continue

        rounds = rounds + 1
        if (config['max_rounds'] != 0) \
                and (rounds > config['max_rounds']) \
                and not terminate:
            print('Error: Reached maximum number of rounds!')
            exit(1)

    # check status of all actions
    for a in actions:
        if a.check_status():
            print('There are some errors')
            exit(1)

    print('done')

if __name__ == '__main__':
    main()
